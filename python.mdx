---
title: "Python"
date: "8-1-2026"
tags: ["Python"]
image: "/images/notes/python.png"
---


## Data types

| Data Type | Mutable | Ex | Desc |
| :--- | :--- | :--- | :--- |
| `int` | ❌ No | `5` | Whole numbers |
| `float` | ❌ No | `5.5` | Decimal numbers |
| `str` | ❌ No | `"Hi"` | Text characters |
| `list` | ✅ Yes | `[1, 2]` | Ordered collection |
| `tuple` | ❌ No | `(1, 2)` | Fixed ordered collection |
| `dict` | ✅ Yes | `{"a": 1}` | Key-value pairs |
| `bool` | ❌ No | `True` | Logic (True/False) |
| `set` | ✅ Yes | `{1, 2}` | Unique items only |


### Constant

Python is dynamically typed language

With Final the type checker will flag any attempts to change the value as an error 

```
from typing import Final
NAME: Final[str] = 'dat'
```

- In Python, a variable is just a name tag (pointer) attached to an object in memory.

```python
x = 5
x = x + 1
```

- You didn't change the number 5 into 6. Instead:

	1. Python created an object 5 and pointed x at it.

	2. When you added 1, Python created a brand new object 6.

	3. Python moved the name tag x from the 5 object to the 6 object.
	4. The object 5 remains unchanged (and is eventually cleaned up if nothing else points to it).

- Python slices follow the `[start:stop]` pattern, where the **start** is included and the **stop** is excluded.

| Slice | Translation | Resulting Indexes |
| :--- | :--- | :--- |
| `[1:3]` | Start at 1, stop **before** 3 | `1, 2` |
| `[:2]` | Start at 0, stop **before** 2 | `0, 1` |
| `[2:]` | Start at 2, go to the end | `2, 3, ...` |
| `[:]` | Copy the whole list | `All indexes` |


- A quick reference guide for when the "End" value is included or excluded in Python functions.

| Syntax | Start (Inclusive) | End (Exclusive) | Resulting Sequence |
| :--- | :---: | :---: | :--- |
`data[0:3]` | ✅ | ❌ | Indexes `0, 1, 2` |
`range(0, 3)` | ✅ | ❌ | Numbers `0, 1, 2` |
`randrange(0, 3)` | ✅ | ❌ | Possible: `0, 1, 2` |
`randint(0, 3)` | ✅ | ✅ | Possible: `0, 1, 2, 3` |

### List

- Ordered, mutable, allow duplicate
```python
colors = ["red", "green", "blue"]
```

- **append()** to add item at end, **insert()** to add item at specified index

- **extend()** use to append a list with iterable objects (**lists, tupe, set, dict**)

```python
s1 = {7,8,9}
l1 = [1,2,3]
t1 = (4,5,6)
d1 = {'99': [1,2,3]}

l1.extend(s1)
l1.extend(t1)
l1.extend(d1)

print(l1) # [1, 2, 3, 8, 9, 7, 4, 5, 6, '99']
```

- **remove(item)**, **pop(index)** if you do not specify the index, pop the last

- **del()** remove the variable while **clear()** clearing items

- Copy a list: **copy( )**, **list( )**, **l1[ : ]**

- Use ``*`` to repeating list or tuple

```python
l2 = l1 * 2
```

**List unpacking**

```py
colors = ["red", "green", "blue"]
r, g, b = colors
```

**List comprehension**

```python
newlist = [expression for item in iterable if condition == True]
l1 = [1,2,3]
l2 = [x for x in l1]
print(l2) # [1,2,3]
```

### Tuple

- Ordered, immutable

```python
location = (40.7, 74.0)
```

### Dict

- Ordered, mutable but the keys must be immuatable, value can be any

```python
user = {"name": "A", "age": 22}
```


### Sets

```python
my_set = {1, 9, 22, '1', '3'}
```

- Unorder, mutable, can only contain unique and immutable items, fast for lookup (use `in`)

- **add()** add item to set (only **immutable**)

- **update()** add **iterable object** (tuples, lists, dictionaries, string) to set

<mark>Note: `set.update(mydict.items())` will add as tuple</mark>

- To remove use **remove()** or **discard()** (will NOT raise an error)

- When use pop(), you do not know which item that gets removed.



## Walrus operator

It combining assignment and evaluation in a single step

```py
# With walrus operator
if (value := input("Enter a number: ")):
    print(f'You entered {value}')
```


## Iterable and Iterator

**Iterable**: An object that can be looped over (e.g., in a for loop) or passed to the built-in iter() function to get an iterator. Lists, tuples, sets, dict, string, and range objects are iterables.

**Iterator**: An object that maintains its state during iteration and can be advanced using the built-in next() and iter() function. Once an iterator is exhausted (all its values have been returned), it cannot be reused

range() is an iterable, but it is not an iterator

- You cannot call next() directly on a range object.

```py
r = range(5)
next(r)
TypeError: 'range' object is not an iterator
```

- You can iterate over a range object multiple times because it doesn't maintain an internal state that gets consumed. Each time you loop over it (or call iter() on it), it produces a fresh, independent iterator object:

```py
r = range(3)
i1 = iter(r)
next(i1) # 0
next(i1) # 1
i2 = iter(r) # Create a new iterator from the same range
next(i2) # 0 (i2 starts from the beginning)
next(i1) # 2 (i1 continues where it left off)
```

## Function

As specified in the PEP 8 style guide, is **snake_case** (lowercase with words separated by underscores)

### Dunder methods

Are the methods starting and ending with double underscores '__' such as

- __init__
- __str__
- __repr__

```py
cbr = Vehicle() # __init__()
print(cbr) # __str__()
print(repr(crb)) # __repr__()
```

### Context manager

Is an object that guarantees the setup and teardown of resources, even if errors occur during execution

The most common way to use a context manager is with the with statement, which automatically handles the necessary "enter" and "exit" steps. 

```py
# Using a context manager (recommended)
with open('some_file.txt', 'w') as f:
    f.write('Hola!')
# The file is automatically closed when the 'with' block is exited
```

### *args/ **kwargs

**\*args** accept number of positional arguments.
	
- args become a **tuple**

``` python
def my_function(*args):
  print(typeof(args)) # tuple

my_function("Emil", "Tobias", "Linus") 
```

**\*\*kwargs** accept number of keyword arguments

- kwargs become a **dictionary**

```python
def my_function(**kwargs):
  print(typeof(kwargs)) # dict

my_function(fname = "Tobias", lname = "Refsnes") 
```

<strong> Combine \*args and **kwargs </strong>

``` python
def my_function(title, *args, **kwargs):
  print("Title:", title)
  print("Positional arguments:", args)
  print("Keyword arguments:", kwargs)

my_function("User Info", "Emil", "Tobias", age = 25, city = "Oslo") 
```

<strong>Unpacking list with *</strong>

``` python
def my_function(a, b, c):
  return a + b + c

numbers = [1, 2, 3]
result = my_function(*numbers) # Same as: my_function(1, 2, 3)
print(result) 
```

<strong>Unpacking Dictionaries with ** </strong>

``` python
def my_function(fname, lname):
  print("Hello", fname, lname)

person = {"fname": "Emil", "lname": "Refsnes"}
my_function(**person) # Same as: my_function(fname="Emil", lname="Refsnes") 
```

<mark>Note: Use `*`and `**` in function definitions to collect arguments, and use them in function calls to unpack arguments</mark>

### Decorator

Decorators add extra behavior to a function, without changing the function's code.

A decorator is a function that takes another function as input and returns a new function.


```py
def my_decorator(func):
  """
  A simple decorator
  """
  def wrapper(*args, **kwargs):
    print('before func call')
    result = func(*args, **kwargs)
    print('after func call')
    return result

  return wrapper

@my_decorator
def greeting():
  print("Hello")

# greeting = my_decorator(greeting)
greeting()
```

### Format string

```python
user = {
  'name' : 'dat',
  'coins' : 3
}

print(("{name} has {coins} coins left").format(**user))

print(f"{user['name']} has {user['coins']} coins left")
```

### Lamda

Lambda functions are commonly used with built-in functions like `map()`, `filter()`, `sorted()` and `reduce()`.

```py
numbers = [1, 2, 3, 4, 5]
doubled = list(map(lambda x: x * 2, numbers))
print(doubled) # [2, 4, 6]
```

```py
numbers = [1, 2, 3, 4, 5, 6, 7, 8]
odd_numbers = list(filter(lambda x: x % 2 != 0, numbers))
print(odd_numbers) # [1, 3, 5, 7]
```

```py

colors = ["red", "green", "blue"]
char_count = reduce(lambda prev, curr:  prev + len(curr), colors, 0)

from functools import reduce
sorted_words = sorted(colors, key=lambda x: len(x))
```

## Classes

```py
class Vehicle:
	color = 'red' # class property
	def __init__(self, name = 'Honda'):
		self.name = name # instance  property

  def __str__(self): # to_string function
		return f"{self.name} {self.color}"

cbr = Vehicle('cbr')

print(cbr.name)
```

<mark>Note: The self parameter must be the first parameter of any method in the class.</mark>

**del** used to delete object or properties of object

### Inheritance

```py
class Student(Person):
  def __init__(self, fname, lname):
    #add properties etc.
```

<mark>Notes: The child's `__init__()` function overrides the inheritance of the parent's `__init__()` function.</mark>

To keep **__init__** function from the parent

```py
Person.__init__(self, fname, lname)
super().__init__(fname, lname) 
```
### Encapsulation

In Python, you can make properties/ methods private by using a double underscore __ prefix, for protected use a single underscore _ prefix:

```py
 class Person:
  def __init__(self, name, age, salary):
    self.name = name
    self.__age = age # Private property
    self._salary = salary # Protected property

p1 = Person("Emil", 25)
print(p1.name)
print(p1.__age) # This will cause an error 
```

## F-String

### Self-documenting

When add `=` sign, Python defaults to using the repr() representation of that object

```py
name = 'dat'
print(f'{name = }') # name = dat
```

### Format number

Use `.nf` where n is the number of decimal points.
  - ex: `{3.14159:.2f} 3.14`

Use `,` to add thousands separators.
  - ex: `{1000000:,} 1,000,000`

Use `%` to multiply by 100 and add a percent sign
  - ex: `{0.25:.1%} 25.0%`

### Format date

```py
now: datetime = datetime.now()
date_format = '%d/%m/%y'

print(f'{now:{date_format}}')
```

### Conversion Flag

Convert an object into a string using a specific method

- **!s**: Calls str() on the value.

- **!r**: Calls repr() on the value (often used for debugging).

- **!a**: Calls ascii() on the value

```py
print(f"{object!r}")
```

### Alignment and Padding

Left Align `<`: `{var:<10}` aligns text to the left in a 10-character field.

Right Align `>`: `{var:>10}` aligns text to the right.

Center Align `^`:`{var:^10}` centers the text.

Padding: Adding a character before the alignment symbol fills the empty space.
- ex: `{var:*^10}` centers the variable and pads it with *.

## Enum

A class that with some concept

- **Symbolic Names**: Enums use meaningful, descriptive names (conventionally in UPPER_CASE).

- **Constants, Unique**: Members defined within an enum are unique and constant.

- **Type-Safety**: Enums preventing errors from typos.

```py
from enum import Enum

class Color(Enum):
  Red = 'R'
  Green = 'G'
  Blue = 'B'

print(Color('R')) # Color.Red
print(Color.Red) # Color.Red
print(repr(Color.Red)) # <Color.Red: 'R'>
print(Color.Red.value) # R
print(Color.Red.name) # Red
```